//@version=6
indicator("HD Volatility Trail [Stats+OffsetSim]", shorttitle="HD-VTrail Stats", overlay=true, max_labels_count=500, max_lines_count=500)

//====================
// Inputs
//====================
grpCore   = "Core Settings"
grpDyn    = "Vol / Trend Adaption"
grpFlip   = "Flip Logic"
grpLabel  = "Label Settings"
grpColor  = "Colours"
grpStats  = "Statistics Dashboard"

emaLen      = input.int(8,   "Basis EMA Length", minval=2, group=grpCore)
atrLen      = input.int(14,  "ATR Length",       minval=1, group=grpCore)
baseMult    = input.float(2, "Base ATR Multiplier", minval=0.1, step=0.1, group=grpCore)

// Volatility & trend adaption
volLookback   = input.int(20,  "Volatility Lookback", minval=2, group=grpDyn)
volPower      = input.float(1.0, "Vol Stretch Sensitivity", minval=0.1, step=0.05, group=grpDyn)
trendLookback = input.int(25, "Trend Memory Length", minval=2, group=grpDyn)
trendImpact   = input.float(0.4, "Trend Impact (0..1)", minval=0.0, maxval=1.0, step=0.05, group=grpDyn)

// Bounds & confirmation
multMin     = input.float(1.0, "Min Effective Mult", minval=0.1, step=0.1, group=grpFlip)
multMax     = input.float(4.0, "Max Effective Mult", minval=0.5, step=0.1, group=grpFlip)
confirmBars = input.int(1,   "Bars Needed To Flip", minval=1, group=grpFlip)

// Label / visuals
showLabels  = input.bool(true, "Show Flip Labels", group=grpLabel)
lblOffsetK  = input.float(0.7, "Label Offset (x ATR)", minval=0.1, step=0.1, group=grpLabel)
lblSizeOpt  = input.string("Normal", "Label Size", options=["Tiny","Small","Normal","Large","Huge"], group=grpLabel)

bullCol     = input.color(color.rgb(0, 190, 160), "Bull Colour", group=grpColor)
bearCol     = input.color(color.rgb(210, 40, 140), "Bear Colour", group=grpColor)
flatCol     = input.color(color.new(color.gray, 75), "Flat Colour", group=grpColor)

// Stats Settings
showStats     = input.bool(true, "Show Stats Table", group=grpStats)
tableSize     = input.string("Small", "Table Size", options=["Tiny", "Small", "Normal", "Large"], group=grpStats)
statsTopPct   = input.int(20, "Top % Length (Percentile)", minval=1, maxval=99, group=grpStats, tooltip="Shows the duration threshold for the longest X% of trends.")
ignoreMargin  = input.int(5, "Wick Filter Margin (Bars)", minval=0, group=grpStats, tooltip="Bars to ignore at start/end of trend.")
useDateFilter = input.bool(false, "Enable Start Date Filter", group=grpStats)
startDate     = input.time(timestamp("2024-01-01 00:00"), "Start Date", group=grpStats)
// Offset for Stats Simulation
slOffset      = input.float(0.0, "Hypothetical SL Offset (Price)", minval=0.0, group=grpStats, tooltip="Does NOT change chart. Only calculates stats for 'What if I added this offset to my stop loss?'.")

//====================
// Helpers
//====================
toSize(str) =>
    sz = size.normal
    if str == "Tiny"
        sz := size.tiny
    else if str == "Small"
        sz := size.small
    else if str == "Large"
        sz := size.large
    else if str == "Huge"
        sz := size.huge
    sz

toTableSize(str) =>
    sz = size.normal
    if str == "Tiny"
        sz := size.tiny
    else if str == "Small"
        sz := size.small
    else if str == "Large"
        sz := size.large
    sz

f_bars_to_time(bars) =>
    secsPerBar = timeframe.in_seconds(timeframe.period)
    totalSecs = bars * secsPerBar
    days = math.floor(totalSecs / 86400)
    rem  = totalSecs % 86400
    hours = math.floor(rem / 3600)
    rem2 = rem % 3600
    mins = math.floor(rem2 / 60)
    res = ""
    if days > 0
        res := str.format("{0}d {1}h", days, hours)
    else if hours > 0
        res := str.format("{0}h {1}m", hours, mins)
    else
        res := str.format("{0}m", mins)
    res

f_fmt_cell(val) =>
    str.tostring(val, "#") + " (" + f_bars_to_time(val) + ")"

//====================
// Core series
//====================
basis   = ta.ema(close, emaLen)
atr     = ta.atr(atrLen)
atrAvg  = ta.sma(atr, volLookback)
volStretchRaw = atrAvg == 0.0 ? 1.0 : atr / atrAvg
volStretch    = math.pow(volStretchRaw, volPower)
slope        = basis - basis[1]
dirStep      = slope >= 0.0 ? 1.0 : -1.0
trendMemory  = ta.ema(dirStep, trendLookback)
trendBoost   = 1.0 + trendImpact * math.abs(trendMemory)
multRaw   = baseMult * volStretch * trendBoost
multUpper = math.min(multRaw, multMax)
multFinal = math.max(multUpper, multMin)

// Bands (Original - NO Offset Here)
bandTop   = basis + multFinal * atr
bandBot   = basis - multFinal * atr

//====================
// Trailing logic
//====================
var float trailLong  = na
var float trailShort = na
var int   regime     = 0

if na(trailLong)
    trailLong := bandBot
if na(trailShort)
    trailShort := bandTop

var int bullCount = 0
var int bearCount = 0
aboveShort = close > trailShort
belowLong  = close < trailLong

if aboveShort
    bullCount += 1
else
    bullCount := 0
if belowLong
    bearCount += 1
else
    bearCount := 0

if regime == 1
    trailLong  := math.max(bandBot, nz(trailLong[1], bandBot))
    trailShort := bandTop
else if regime == -1
    trailShort := math.min(bandTop, nz(trailShort[1], bandTop))
    trailLong  := bandBot
else
    trailLong  := bandBot
    trailShort := bandTop

prevRegime = regime

if regime == 0
    if bullCount >= confirmBars
        regime := 1
    else if bearCount >= confirmBars
        regime := -1
else if regime == 1 and bearCount >= confirmBars
    regime := -1
else if regime == -1 and bullCount >= confirmBars
    regime := 1

//====================
// Statistics Logic
//====================
var bullDurations = array.new_int()
var bearDurations = array.new_int()

// Standard Wicks
var bullWickFlags = array.new_int()
var bearWickFlags = array.new_int()
var int[] currentTrendWickBars = array.new_int()

// Buffered Wicks (Hypothetical)
var bullWickFlagsOffset = array.new_int()
var bearWickFlagsOffset = array.new_int()
var int[] currentTrendWickBarsOffset = array.new_int()

var int startBar = bar_index

isBullFlip = regime == 1 and prevRegime != 1
isBearFlip = regime == -1 and prevRegime != -1

// 1. Record Wick Locations (Parallel Check)
bool isWickNow = false
bool isWickNowOffset = false

if regime == 1
    // Standard: Low < Trail
    if low < trailLong
        isWickNow := true
    // Buffered: Low < Trail - Offset
    if low < (trailLong - slOffset)
        isWickNowOffset := true
        
else if regime == -1
    // Standard: High > Trail
    if high > trailShort
        isWickNow := true
    // Buffered: High > Trail + Offset
    if high > (trailShort + slOffset)
        isWickNowOffset := true

if isWickNow
    array.push(currentTrendWickBars, bar_index)
if isWickNowOffset
    array.push(currentTrendWickBarsOffset, bar_index)

// 2. Process Completed Trends
shouldRecord = not useDateFilter or time >= startDate

if isBullFlip or isBearFlip
    if prevRegime != 0 and shouldRecord
        trendEndBar = bar_index - 1
        duration = bar_index - startBar
        
        // --- Verify Standard Wicks ---
        bool hasValidWick = false
        if array.size(currentTrendWickBars) > 0
            for tBar in currentTrendWickBars
                if tBar > (startBar + ignoreMargin) and tBar < (trendEndBar - ignoreMargin)
                    hasValidWick := true
                    break 
        
        // --- Verify Buffered Wicks ---
        bool hasValidWickOffset = false
        if array.size(currentTrendWickBarsOffset) > 0
            for tBar in currentTrendWickBarsOffset
                if tBar > (startBar + ignoreMargin) and tBar < (trendEndBar - ignoreMargin)
                    hasValidWickOffset := true
                    break 

        if prevRegime == 1
            array.push(bullDurations, duration)
            array.push(bullWickFlags, hasValidWick ? 1 : 0)
            array.push(bullWickFlagsOffset, hasValidWickOffset ? 1 : 0)
        else if prevRegime == -1
            array.push(bearDurations, duration)
            array.push(bearWickFlags, hasValidWick ? 1 : 0)
            array.push(bearWickFlagsOffset, hasValidWickOffset ? 1 : 0)
    
    startBar := bar_index
    array.clear(currentTrendWickBars)
    array.clear(currentTrendWickBarsOffset)

//====================
// Visuals
//====================
isBull  = regime == 1
isBear  = regime == -1

pShort  = plot(trailShort, "Short Trail", color=isBear ? bearCol : flatCol, style=plot.style_linebr, linewidth=2)
pLong   = plot(trailLong,  "Long Trail",  color=isBull ? bullCol : flatCol, style=plot.style_linebr, linewidth=2)
fill(pShort, plot(close, display=display.none), color=isBear ? color.new(bearCol, 80) : color.new(color.gray, 100), title="Bear Zone")
fill(pLong,  plot(close, display=display.none), color=isBull ? color.new(bullCol, 80) : color.new(color.gray, 100), title="Bull Zone")
barcolor(isBull ? bullCol : isBear ? bearCol : flatCol)

//====================
// Flip markers
//====================
lblSize = toSize(lblSizeOpt)
if showLabels and isBullFlip
    label.new(bar_index, trailLong - lblOffsetK * atr, "Long", style=label.style_label_up, size=lblSize, color=color.new(bullCol, 0), textcolor=color.black)
if showLabels and isBearFlip
    label.new(bar_index, trailShort + lblOffsetK * atr, "Short", style=label.style_label_down, size=lblSize, color=color.new(bearCol, 0), textcolor=color.white)
alertcondition(isBullFlip, "HD-VTrail Bull Flip", "Bullish flip")
alertcondition(isBearFlip, "HD-VTrail Bear Flip", "Bearish flip")

//====================
// Dashboard Table
//====================
var int firstBarTime = time

f_calc_percentile(arr, topPct) =>
    val = 0.0
    sz = array.size(arr)
    if sz > 0
        sArr = array.copy(arr)
        array.sort(sArr, order.ascending)
        idx = math.round((sz - 1) * (1.0 - topPct/100.0))
        val := array.get(sArr, int(idx))
    val

// Stats Calc
f_calc_stats_generic(durs, wicks, topPct) =>
    cnt = array.size(durs)
    if cnt == 0
        [0.0, 0.0, 0.0, 0.0, 0] 
    else
        avg = array.avg(durs)
        med = array.median(durs)
        topK = f_calc_percentile(durs, topPct)
        wickSum = array.sum(wicks)
        wickPct = (wickSum / cnt) * 100
        [avg, med, topK, wickPct, cnt]

if showStats and barstate.islast
    var tbl = table.new(position.bottom_right, 4, 7, border_width=1)
    
    // logic fix: Use the later of the two dates to show the REAL start time
    effectiveStart = useDateFilter ? math.max(startDate, firstBarTime) : firstBarTime
    startTimeStr = str.format("{0,date,yyyy-MM-dd}", effectiveStart)
    
    // Calc Standard
    [bullAvg, bullMed, bullTopK, bullWickPct, bullCnt] = f_calc_stats_generic(bullDurations, bullWickFlags, statsTopPct)
    [bearAvg, bearMed, bearTopK, bearWickPct, bearCnt] = f_calc_stats_generic(bearDurations, bearWickFlags, statsTopPct)
    
    // Calc Offset Sim (Re-using duration arrays, but passing OFFSET wick arrays)
    [_b1, _b2, _b3, bullWickPctOff, _b4] = f_calc_stats_generic(bullDurations, bullWickFlagsOffset, statsTopPct)
    [_r1, _r2, _r3, bearWickPctOff, _r4] = f_calc_stats_generic(bearDurations, bearWickFlagsOffset, statsTopPct)
    
    // Header
    table.cell(tbl, 0, 0, "Metric (Since " + startTimeStr + ")", bgcolor=color.gray, text_color=color.white, text_size=toTableSize(tableSize))
    table.cell(tbl, 1, 0, "Bull Trend", bgcolor=bullCol, text_color=color.black, text_size=toTableSize(tableSize))
    table.cell(tbl, 2, 0, "Bear Trend", bgcolor=bearCol, text_color=color.white, text_size=toTableSize(tableSize))
    
    // Data Rows
    table.cell(tbl, 0, 1, "Trend Count", bgcolor=color.new(color.gray, 90), text_size=toTableSize(tableSize))
    table.cell(tbl, 1, 1, str.tostring(bullCnt), bgcolor=color.new(bullCol, 90), text_size=toTableSize(tableSize))
    table.cell(tbl, 2, 1, str.tostring(bearCnt), bgcolor=color.new(bearCol, 90), text_size=toTableSize(tableSize))
    
    table.cell(tbl, 0, 2, "Avg Length", bgcolor=color.new(color.gray, 90), text_size=toTableSize(tableSize))
    table.cell(tbl, 1, 2, f_fmt_cell(bullAvg), bgcolor=color.new(bullCol, 90), text_size=toTableSize(tableSize))
    table.cell(tbl, 2, 2, f_fmt_cell(bearAvg), bgcolor=color.new(bearCol, 90), text_size=toTableSize(tableSize))
    
    table.cell(tbl, 0, 3, "Median Length", bgcolor=color.new(color.gray, 90), text_size=toTableSize(tableSize))
    table.cell(tbl, 1, 3, f_fmt_cell(bullMed), bgcolor=color.new(bullCol, 90), text_size=toTableSize(tableSize))
    table.cell(tbl, 2, 3, f_fmt_cell(bearMed), bgcolor=color.new(bearCol, 90), text_size=toTableSize(tableSize))
    
    pctLabel = "Top " + str.tostring(statsTopPct) + "% Length"
    table.cell(tbl, 0, 4, pctLabel, bgcolor=color.new(color.gray, 90), text_size=toTableSize(tableSize))
    table.cell(tbl, 1, 4, f_fmt_cell(bullTopK), bgcolor=color.new(bullCol, 90), text_size=toTableSize(tableSize))
    table.cell(tbl, 2, 4, f_fmt_cell(bearTopK), bgcolor=color.new(bearCol, 90), text_size=toTableSize(tableSize))
    
    table.cell(tbl, 0, 5, "Wick Risk % (Standard)", bgcolor=color.new(color.gray, 90), text_size=toTableSize(tableSize), tooltip="Probability of wicking the actual indicator line.")
    table.cell(tbl, 1, 5, str.tostring(bullWickPct, "#.1") + "%", bgcolor=color.new(bullCol, 90), text_size=toTableSize(tableSize))
    table.cell(tbl, 2, 5, str.tostring(bearWickPct, "#.1") + "%", bgcolor=color.new(bearCol, 90), text_size=toTableSize(tableSize))

    // New Offset Row
    offLabel = "Wick Risk % (w/ Offset " + str.tostring(slOffset) + ")"
    table.cell(tbl, 0, 6, offLabel, bgcolor=color.new(color.gray, 80), text_size=toTableSize(tableSize), tooltip="Simulated Risk if you added the configured price offset to your stop loss.")
    table.cell(tbl, 1, 6, str.tostring(bullWickPctOff, "#.1") + "%", bgcolor=color.new(bullCol, 80), text_size=toTableSize(tableSize))
    table.cell(tbl, 2, 6, str.tostring(bearWickPctOff, "#.1") + "%", bgcolor=color.new(bearCol, 80), text_size=toTableSize(tableSize))